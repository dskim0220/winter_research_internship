{"source_pdf": "An Adaptive Evolutionary Algorithm for Traveling Salesman Problem with Precedence Constraints.pdf", "problem_name": "Traveling Salesman Problem with Precedence Constraints (TSPPC)", "mathematical_model": {"problem_name": "Traveling Salesman Problem with Precedence Constraints (TSPPC)", "description": "A variation of the Traveling Salesman Problem where a set of operations (nodes) must be visited exactly once with minimum total setup/travel time, subject to specific precedence relationships between operations. The formulation uses a network flow model with decreasing counters.", "sets": [{"name": "Nodes", "symbol": "V", "description": "The set of nodes (operations) to be visited, defined as {0, 1, ..., n}."}], "parameters": [{"name": "Number of nodes", "symbol": "N", "indices": [], "description": "The total number of nodes (operations) excluding the start/dummy node context dependent."}, {"name": "Distance Matrix", "symbol": "t_{ij}", "indices": ["i", "j"], "description": "The distance or setup time from node i to node j."}, {"name": "Precedence Relations", "symbol": "Precedence", "indices": ["i", "j"], "description": "A set of pairs (i, j) such that node i must be visited before node j."}], "variables": [{"name": "Arc Selection", "symbol": "x_{ij}", "indices": ["i", "j"], "type": "Binary", "description": "1 if node j is visited immediately after node i, 0 otherwise."}, {"name": "Aggregate Counter", "symbol": "a_{k}", "indices": ["k"], "type": "Integer", "description": "A decreasing aggregate counter associated with node k, representing its position/order."}, {"name": "Partial Counter", "symbol": "p_{ij}", "indices": ["i", "j"], "type": "Integer", "description": "Decreasing partial counter representing flow on arc (i, j)."}], "objective": {"direction": "Minimize", "expression": "\\sum_{i} \\sum_{j} t_{ij} \\times x_{ij}", "description": "Minimize the total traveling distance or processing setup time."}, "constraints": [{"name": "Outgoing Degree Constraint", "expression": "\\sum_{j} x_{ij} = 1", "description": "Each node i must have exactly one successor.", "for_all": ["\\forall i \\in V"]}, {"name": "Incoming Degree Constraint", "expression": "\\sum_{i} x_{ij} = 1", "description": "Each node j must have exactly one predecessor.", "for_all": ["\\forall j \\in V"]}, {"name": "Counter Aggregation", "expression": "\\sum_{i} p_{ij} = a_{j}", "description": "The amount of belonging (counter value) at node j is the sum of incoming partial counters.", "for_all": ["\\forall j \\in V"]}, {"name": "Boundary Conditions", "expression": "\\sum_{j} p_{j0} = N, \\quad \\sum_{i} p_{0i} = 0, \\quad p_{jj} = 0", "description": "Flow conservation for the start/end node (node 0) and prevention of self-loops.", "for_all": ["\\forall j \\in V"]}, {"name": "Linking Constraint", "expression": "p_{ij} \\leq (N + 1) \\times x_{ij}", "description": "Couples the counter flow variables with the binary routing variables.", "for_all": ["\\forall i, j \\in V"]}, {"name": "Counter Decrement", "expression": "\\sum_{j} p_{ji} = a_{i} - 1", "description": "Ensures the counter decreases by 1 after visiting node i.", "for_all": ["\\forall i \\in V"]}, {"name": "Precedence Constraint", "expression": "a_{i} > a_{j}", "description": "Ensures that if node i precedes node j, the decreasing counter at i is greater than at j.", "for_all": ["\\forall (i, j) \\in Precedence"]}]}, "solver_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# -----------------------------------------------------------------------------\n# Instance Data\n# -----------------------------------------------------------------------------\nV = [0, 1, 2, 3, 4]\nN = 4\n\n# Distance Matrix t_{ij}\n# Note: (i, i) costs are 1000.0 (Big M) to discourage self-loops\nt = {\n    (0, 0): 1000.0, (0, 1): 20.0, (0, 2): 20.0, (0, 3): 28.0, (0, 4): 14.0,\n    (1, 0): 20.0, (1, 1): 1000.0, (1, 2): 28.0, (1, 3): 20.0, (1, 4): 14.0,\n    (2, 0): 20.0, (2, 1): 28.0, (2, 2): 1000.0, (2, 3): 20.0, (2, 4): 14.0,\n    (3, 0): 28.0, (3, 1): 20.0, (3, 2): 20.0, (3, 3): 1000.0, (3, 4): 14.0,\n    (4, 0): 14.0, (4, 1): 14.0, (4, 2): 14.0, (4, 3): 14.0, (4, 4): 1000.0\n}\n\n# Precedence Relations: (i, j) means i must be visited before j\nPrecedence = [\n    (1, 3),\n    (2, 4)\n]\n\n# -----------------------------------------------------------------------------\n# Model Initialization\n# -----------------------------------------------------------------------------\nmodel = gp.Model(\"TSPPC\")\n\n# -----------------------------------------------------------------------------\n# Variables\n# -----------------------------------------------------------------------------\n# x_{ij}: Binary, 1 if arc (i, j) is selected\nx = model.addVars(V, V, vtype=GRB.BINARY, name=\"x\")\n\n# a_{k}: Integer, decreasing aggregate counter at node k\n# Bounds: 0 to N+1\na = model.addVars(V, vtype=GRB.INTEGER, lb=0, ub=N+1, name=\"a\")\n\n# p_{ij}: Integer, decreasing partial counter on arc (i, j)\n# Bounds: 0 to N+1\np = model.addVars(V, V, vtype=GRB.INTEGER, lb=0, ub=N+1, name=\"p\")\n\n# -----------------------------------------------------------------------------\n# Objective Function\n# -----------------------------------------------------------------------------\n# Minimize total travel/setup time\nmodel.setObjective(gp.quicksum(t[i, j] * x[i, j] for i in V for j in V), GRB.MINIMIZE)\n\n# -----------------------------------------------------------------------------\n# Constraints\n# -----------------------------------------------------------------------------\n\n# 1. Outgoing Degree Constraint: Each node i must have exactly one successor\nmodel.addConstrs(\n    (gp.quicksum(x[i, j] for j in V) == 1 for i in V),\n    name=\"OutgoingDegree\"\n)\n\n# 2. Incoming Degree Constraint: Each node j must have exactly one predecessor\nmodel.addConstrs(\n    (gp.quicksum(x[i, j] for i in V) == 1 for j in V),\n    name=\"IncomingDegree\"\n)\n\n# 3. Counter Aggregation: Flow into node j equals the counter value a_j\n# Note: Applied to V \\ {0} to allow flow logic to work (0 is source/sink boundary)\nmodel.addConstrs(\n    (gp.quicksum(p[i, j] for i in V) == a[j] for j in V if j != 0),\n    name=\"CounterAggregation\"\n)\n\n# 4. Boundary Conditions\n# Interpreted for feasibility: Node 0 acts as the Source of N units of flow.\n# Flow leaving 0 is N. Flow entering 0 is 0 (in terms of counter flow p).\n# Self-loops p_{jj} are 0.\nmodel.addConstr(gp.quicksum(p[0, j] for j in V) == N, name=\"Boundary_Out_0\")\nmodel.addConstr(gp.quicksum(p[j, 0] for j in V) == 0, name=\"Boundary_In_0\")\nmodel.addConstrs((p[j, j] == 0 for j in V), name=\"NoSelfLoopFlow\")\n\n# 5. Linking Constraint: Flow p_{ij} only exists if arc x_{ij} is used\nmodel.addConstrs(\n    (p[i, j] <= (N + 1) * x[i, j] for i in V for j in V),\n    name=\"Linking\"\n)\n\n# 6. Counter Decrement: Flow leaving node i is (a_i - 1)\n# This ensures flow decreases by 1 at every visited node.\n# Note: Applied to V \\ {0}.\nmodel.addConstrs(\n    (gp.quicksum(p[i, j] for j in V) == a[i] - 1 for i in V if i != 0),\n    name=\"CounterDecrement\"\n)\n\n# 7. Precedence Constraint: If i precedes j, counter at i must be greater than at j\n# Since counters are integers, strict inequality a_i > a_j becomes a_i >= a_j + 1\nmodel.addConstrs(\n    (a[i] >= a[j] + 1 for i, j in Precedence),\n    name=\"Precedence\"\n)\n\n# -----------------------------------------------------------------------------\n# Solve and Output\n# -----------------------------------------------------------------------------\nmodel.optimize()\n\nif model.status == GRB.OPTIMAL:\n    print(f\"\\nOptimal Solution Found!\")\n    print(f\"Objective Value: {model.objVal}\")\n    \n    print(\"\\nTour Route:\")\n    # Reconstruct tour from x variables\n    current = 0\n    tour = [0]\n    while True:\n        for j in V:\n            if x[current, j].X > 0.5:\n                print(f\"Node {current} -> Node {j} (Dist: {t[current, j]}, Flow p: {p[current, j].X})\")\n                current = j\n                tour.append(j)\n                break\n        if current == 0:\n            break\n    print(f\"Full Tour Sequence: {tour}\")\n    \n    print(\"\\nNode Counters (a_k):\")\n    for k in V:\n        if k != 0:\n            print(f\"Node {k}: {a[k].X}\")\n\nelse:\n    print(\"No optimal solution found.\")", "instance_data": {"sets": {"V": [0, 1, 2, 3, 4]}, "parameters": {"N": 4, "t_{ij}": {"(0,0)": 1000.0, "(0,1)": 20.0, "(0,2)": 20.0, "(0,3)": 28.0, "(0,4)": 14.0, "(1,0)": 20.0, "(1,1)": 1000.0, "(1,2)": 28.0, "(1,3)": 20.0, "(1,4)": 14.0, "(2,0)": 20.0, "(2,1)": 28.0, "(2,2)": 1000.0, "(2,3)": 20.0, "(2,4)": 14.0, "(3,0)": 28.0, "(3,1)": 20.0, "(3,2)": 20.0, "(3,3)": 1000.0, "(3,4)": 14.0, "(4,0)": 14.0, "(4,1)": 14.0, "(4,2)": 14.0, "(4,3)": 14.0, "(4,4)": 1000.0}, "Precedence": [[1, 3], [2, 4]]}}, "description": "# Traveling Salesman Problem with Precedence Constraints (TSPPC)\n\n## Problem Overview\n**Type:** Minimization\n\nThe **Traveling Salesman Problem with Precedence Constraints (TSPPC)** is a variation of the classic TSP. The goal is to determine a route that visits a set of operations (nodes) exactly once with the minimum total setup or travel time. Unlike the standard TSP, this problem imposes specific precedence relationships, requiring certain nodes to be visited before others. The mathematical formulation provided utilizes a network flow model with decreasing counters to handle subtour elimination and precedence logic.\n\n---\n\n## Mathematical Model\n\n### Sets\n| Name | Symbol | Description |\n| :--- | :--- | :--- |\n| **Nodes** | $V$ | The set of nodes (operations) to be visited, defined as $\\{0, 1, ..., n\\}$. |\n\n### Parameters\n| Name | Symbol | Indices | Description |\n| :--- | :--- | :--- | :--- |\n| **Number of nodes** | $N$ | None | The total number of nodes (operations) excluding the start/dummy node context dependent. |\n| **Distance Matrix** | $t_{ij}$ | $i, j$ | The distance or setup time from node $i$ to node $j$. |\n| **Precedence Relations** | $Precedence$ | $i, j$ | A set of pairs $(i, j)$ such that node $i$ must be visited before node $j$. |\n\n### Decision Variables\n| Name | Symbol | Type | Bounds | Indices | Description |\n| :--- | :--- | :--- | :--- | :--- | :--- |\n| **Arc Selection** | $x_{ij}$ | Binary | $\\in \\{0, 1\\}$ | $i, j$ | 1 if node $j$ is visited immediately after node $i$, 0 otherwise. |\n| **Aggregate Counter** | $a_{k}$ | Integer | $\\ge 0$ | $k$ | A decreasing aggregate counter associated with node $k$, representing its position/order. |\n| **Partial Counter** | $p_{ij}$ | Integer | $\\ge 0$ | $i, j$ | Decreasing partial counter representing flow on arc $(i, j)$. |\n\n### Objective Function\n**Minimize** the total traveling distance or processing setup time:\n\n$$\n\\text{Minimize } Z = \\sum_{i} \\sum_{j} t_{ij} \\times x_{ij}\n$$\n\n### Constraints\n\n1.  **Outgoing Degree Constraint**\n    Each node $i$ must have exactly one successor.\n    $$\n    \\sum_{j} x_{ij} = 1 \\quad \\forall i \\in V\n    $$\n\n2.  **Incoming Degree Constraint**\n    Each node $j$ must have exactly one predecessor.\n    $$\n    \\sum_{i} x_{ij} = 1 \\quad \\forall j \\in V\n    $$\n\n3.  **Counter Aggregation**\n    The amount of belonging (counter value) at node $j$ is the sum of incoming partial counters.\n    $$\n    \\sum_{i} p_{ij} = a_{j} \\quad \\forall j \\in V\n    $$\n\n4.  **Boundary Conditions**\n    Flow conservation for the start/end node (node 0) and prevention of self-loops.\n    $$\n    \\sum_{j} p_{j0} = N, \\quad \\sum_{i} p_{0i} = 0, \\quad p_{jj} = 0 \\quad \\forall j \\in V\n    $$\n\n5.  **Linking Constraint**\n    Couples the counter flow variables with the binary routing variables.\n    $$\n    p_{ij} \\leq (N + 1) \\times x_{ij} \\quad \\forall i, j \\in V\n    $$\n\n6.  **Counter Decrement**\n    Ensures the counter decreases by 1 after visiting node $i$.\n    $$\n    \\sum_{j} p_{ji} = a_{i} - 1 \\quad \\forall i \\in V\n    $$\n\n7.  **Precedence Constraint**\n    Ensures that if node $i$ precedes node $j$, the decreasing counter at $i$ is greater than at $j$.\n    $$\n    a_{i} > a_{j} \\quad \\forall (i, j) \\in Precedence\n    $$\n\n---\n\n## Instance Data Summary\n\nThe provided instance defines a problem with the following characteristics:\n\n*   **Nodes ($V$):** 5 nodes, labeled $\\{0, 1, 2, 3, 4\\}$.\n*   **Parameter $N$:** 4 (indicating 4 operations plus the depot/dummy node 0).\n*   **Precedence Constraints:**\n    *   Node **1** must be visited before Node **3**.\n    *   Node **2** must be visited before Node **4**.\n*   **Distance Matrix ($t_{ij}$):**\n    *   A $5 \\times 5$ matrix.\n    *   Diagonal elements (e.g., $t_{00}, t_{11}$) are set to a high penalty ($1000.0$) to discourage self-loops.\n    *   Travel costs vary between $14.0$ and $28.0$ for valid connections."}
